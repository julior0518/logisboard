/* beautiful-react-hooks version: 0.35.0 */
import { slicedToArray as _slicedToArray, objectSpread2 as _objectSpread2 } from './_virtual/_rollupPluginBabelHelpers.js';
import { useState, useRef } from 'react';
import useMouseEvents from './useMouseEvents.js';
import useTouchEvents from './useTouchEvents.js';
import { getPointerCoordinates, getDirection, getHorizontalDirection, getVerticalDirection } from './utils/swipeUtils.js';

var defaultOptions = {
  direction: 'both',
  threshold: 10,
  preventDefault: true
};
var initialState = {
  swiping: false,
  direction: null,
  alphaX: 0,
  alphaY: 0,
  count: 0
};

var isEqual = function isEqual(prev, next) {
  return prev.swiping === next.swiping && prev.direction === next.direction && prev.count === next.count && prev.alphaX === next.alphaX && prev.alphaY === next.alphaY;
};

var useSwipe = function useSwipe() {
  var targetRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

  var _useState = useState(initialState),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var startingPointRef = useRef([-1, -1]);
  var isDraggingRef = useRef(false);

  var opts = _objectSpread2(_objectSpread2({}, defaultOptions), options || {});

  var _useMouseEvents = useMouseEvents(targetRef),
      onMouseDown = _useMouseEvents.onMouseDown,
      onMouseMove = _useMouseEvents.onMouseMove,
      onMouseLeave = _useMouseEvents.onMouseLeave,
      onMouseUp = _useMouseEvents.onMouseUp;

  var _useTouchEvents = useTouchEvents(targetRef),
      onTouchStart = _useTouchEvents.onTouchStart,
      onTouchMove = _useTouchEvents.onTouchMove,
      onTouchEnd = _useTouchEvents.onTouchEnd,
      onTouchCancel = _useTouchEvents.onTouchCancel;

  var startSwipe = function startSwipe(event) {
    var _getPointerCoordinate = getPointerCoordinates(event),
        _getPointerCoordinate2 = _slicedToArray(_getPointerCoordinate, 2),
        clientX = _getPointerCoordinate2[0],
        clientY = _getPointerCoordinate2[1];

    startingPointRef.current = [clientX, clientY];

    if (opts.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
    }
  };

  var continueSwipe = function continueSwipe(event) {
    var _getPointerCoordinate3 = getPointerCoordinates(event),
        _getPointerCoordinate4 = _slicedToArray(_getPointerCoordinate3, 2),
        clientX = _getPointerCoordinate4[0],
        clientY = _getPointerCoordinate4[1];

    if (opts.preventDefault) {
      event.preventDefault();
      event.stopPropagation();
    }

    if (isDraggingRef.current || startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {
      var alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];

      if (opts.direction === 'both' && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {
        isDraggingRef.current = true;
        var nextState = {
          alphaX: alpha[0],
          alphaY: alpha[1],
          count: state.count,
          swiping: true,
          direction: getDirection([clientX, clientY], startingPointRef.current, alpha)
        };

        if (!isEqual(nextState, state)) {
          setState(nextState);
        }
      }

      if (opts.direction === 'horizontal' && Math.abs(alpha[0]) > opts.threshold) {
        isDraggingRef.current = true;
        var _nextState = {
          alphaX: alpha[0],
          alphaY: 0,
          count: state.count,
          swiping: true,
          direction: getHorizontalDirection(alpha[0])
        };

        if (!isEqual(_nextState, state)) {
          setState(_nextState);
        }
      }

      if (opts.direction === 'vertical' && Math.abs(alpha[1]) > opts.threshold) {
        isDraggingRef.current = true;
        var _nextState2 = {
          alphaY: alpha[1],
          alphaX: 0,
          count: state.count,
          swiping: true,
          direction: getVerticalDirection(alpha[1])
        };

        if (!isEqual(_nextState2, state)) {
          setState(_nextState2);
        }
      }
    }
  };

  var endSwipe = function endSwipe(event) {
    if (isDraggingRef.current) {
      if (opts.preventDefault) {
        event.preventDefault();
        event.stopPropagation();
      }

      setState(function (prevState) {
        return _objectSpread2(_objectSpread2({}, prevState), {}, {
          swiping: false,
          count: state.count + 1
        });
      });
    }

    startingPointRef.current = [-1, -1];
    isDraggingRef.current = false;
  };

  onMouseDown(startSwipe);
  onTouchStart(startSwipe);
  onMouseMove(continueSwipe);
  onTouchMove(continueSwipe);
  onMouseUp(endSwipe);
  onTouchEnd(endSwipe);
  onMouseLeave(endSwipe);
  onTouchCancel(endSwipe);
  return state;
};

export default useSwipe;
